What is a messaging system?
A messaging system is a mechanism for communication between applications (Application to Application or A2A). It manages messages between different applications and systems in an organization.

An example of a messaging system in use
Suppose a company has three systems:
Human Resources System (HR System): Manages information about new employees and those who have resigned.
Marketing System: Needs to receive employee information to manage its users.
Active Directory: Used to store usernames and passwords.
Without using a messaging system
A new employee is registered in the HR system resources.
The Marketing system must retrieve information from the HR database every hour and process it itself.
The Active Directory system only receives and processes new data once a day (at 1 am).
This method is that the transfer of information is delayed. Also, each system must be given different file methods (e.g. database, API, text) which adds complexity.

Using RabbitMQ
The HR system sends every change to RabbitMQ.
RabbitMQ receives the message and puts it in a queue.
The Market and Active Directory system receive and process both messages.
In this method, data transfer is done in real-time and there is no need to implement different schedules in different systems.

Major problems with old and important messaging system methods
If the number of applications increases, each application communicates with a large number of other applications. If you have P source applications and Q target applications, you need to set up P Ã— Q communication points which becomes very complicated.
Different communication methods (database, API, file) have different formats which are difficult to manage.
Direct communication may cause applications to crash.

Using RabbitMQ, systems are decoupled, meaning that:
The source system only sends to RabbitMQ.
The target system receives what it needs from RabbitMQ.
All systems communicate in a standard format (e.g. JSON).
RabbitMQ can process large amounts of data quickly.

Run the following command:
docker run -d --name rabbitmq \
  --restart unless-stopped \
  -p 5672:5672 -p 15672:15672 \
  -e RABBITMQ_DEFAULT_USER=admin \
  -e RABBITMQ_DEFAULT_PASS=admin123 \
  -v rabbitmq_data:/var/lib/rabbitmq \
  rabbitmq:management

unless-stopped: Restarts the container unless it has been manually stopped.
always: Even if manually stopped, it will be restarted after a system restart, which is sometimes unnecessary.


How does RabbitMQ work? A simple example
Let's assume we have a specific post office:
Person A logs into the post office and sends a message.
The post office places this message in a specific queue.
Person X has informed this post office that he is interested in messages from a specific queue.
Now, whenever a new message arrives in this queue, the post office sends it to person X to process.

What is Exchange and what does it do?
Exchange acts like a post office employee who sends messages to the appropriate queues.
When it receives a message, it must decide:
Should it send the message to a specific queue?
Should it send the message to several different queues?
Should it delete the message altogether?

ğŸ”¹ If the message needs to be sent to multiple queues, Exchange places a copy of the message in each queue.
Two important concepts: Message Durability and Queue Durability

ğŸ”¹ By default, RabbitMQ stores messages transiently.
That is, if the RabbitMQ server is shut down or crashes, the messages are lost.
Even the queue itself may be deleted unless we define it as Durable.

âœ… How to make messages and queues durable

When we create a queue, we must define it as Durable so that it is not lost after the server is shut down.
This causes the queue structure to be saved on disk and recreated after RabbitMQ is restarted.

Creating a Persistent Message
We must mark each message as Persistent when sending it so that RabbitMQ stores it on disk.
We do this by setting Delivery Mode = Persistent.
âœ… If both the queue and the message are durable, RabbitMQ will try to preserve the messages even if the server is down or crashes.

Simple summary:
RabbitMQ is like a post office that manages messages.
The Producer sends the message, the Exchange sends the message to the appropriate Queue, and the Consumer receives it.
To prevent message loss, we need to make the queue and messages durable and persistent.

Producer: Person A who sends the message - the application that sends the message to RabbitMQ.
Message: The message sent - the information being sent (e.g. a JSON string).
Queue: The queue where the message is placed - a place that holds messages until they are processed.
Consumer: Person X who receives the message - the application that receives and processes messages from the queue.
Subscribe: Person X registers with the post office - the process of expressing interest in receiving messages from a queue.
Consume: Message received by person X - receiving and processing the message from the queue.
Exchange (Message Router): The post office worker that sends messages to queues - the part that receives messages from the Producer and sends them to the appropriate queue.
Routing Key: A tag on the message that specifies which queue to send it to - an address that helps RabbitMQ send the message to the correct queue.
Binding: The connection between Exchange and Queue - the process that determines which Queue to send messages from Exchange to.

What is Classic Queue?
âœ… The default type of queues in RabbitMQ
âœ… Simple and widely used for most projects
âœ… Uses a master node to store messages
âœ… Fast performance, but less immune to message loss

ğŸ”¹ What is the problem with Classic Queue?
âŒ If the master node crashes, messages are lost!
âŒ Not suitable for projects with sensitive data.

ğŸ›  What projects is Classic Queue suitable for?
âœ… Simple systems with a RabbitMQ Server
âœ… Where losing some messages is not a problem
For example: non-sensitive messaging systems, push notifications, and ad-hoc processing

What is Quorum Queue?
âœ… Suitable for projects where messages should not be lost
âœ… Uses multiple nodes to store and backup messages
âœ… If a server crashes, data is not lost
âœ… Uses a consensus algorithm to synchronize data between nodes

ğŸ”¹ How does Quorum Queue protect messages?
ğŸ”¸ Each message is copied to multiple servers (Nodes)
ğŸ”¸ At least half of the nodes + 1 node must store the message
For example, if we have 5 RabbitMQ servers, the message is stored on 3 servers.

ğŸ›  What projects is Quorum Queue suitable for?
âœ… Projects where messages should not be lost
âœ… Banking and financial systems ğŸ’°
âœ… Healthcare and medical services ğŸ¥
âœ… Projects running in a Cluster environment

Which one should we choose in real projects (Production)?
âœ… If data safety and message loss are important â†’ Quorum Queue
âœ… If speed is more important than data safety and message loss is not a problem â†’ Classic Queue
âœ… In this course, both types can be used, but for the real environment (Production), it is better to use Quorum Queue.

Why use JSON? ğŸ¤”
RabbitMQ accepts any string as a message, which is very flexible. But this can cause problems.
ğŸ”¹ Problem: Different message formats
Suppose we have two producers that send messages in different formats:
Producer X separates its data with ||:
Producer Y separates its data with ;:
Now if a consumer (Consumer C) wants to receive these messages, it must know both formats and have different ways to process each format. This adds a lot of complexity to the code.
ğŸ”¹ Solution: Use JSON
With JSON, all the data is in a standard format. This means that different producers do not need to use different ways to separate the data.

ğŸ”¹ What is Exchange in RabbitMQ?
âœ… Exchange is a part of RabbitMQ that receives messages and sends them to the appropriate queues.
âœ… Exchange decides which queue the message should go to.
âœ… Exchange decides which Queue to send the message to based on the "Routing Key".
âœ… The connection between an Exchange and a Queue is called "Binding".

ğŸ”¹ There are different types of Exchanges, each of which sends messages to Queues in a specific way:
Fanout Exchange: Sends the message to all queues connected to the Exchange.
Direct Exchange: Sends the message to a specific queue whose Routing Key exactly matches.
Topic Exchange: Sends messages to different queues based on the Routing Key pattern.

ğŸ”¹ Simple Examples of Exchange Types
âœ… 1. Fanout Exchange â†’ Send message to all queues
ğŸ“Œ Example: Send a notification to all users
The message is sent to all queues connected to the Exchange, no matter what the Routing Key is.

âœ… 2. Direct Exchange â†’ Send to a specific queue
ğŸ“Œ Example: A payment system that sends "successful payment" messages only to the relevant queue.
The message is sent only to the queue whose Routing Key is exactly equal to the specified value.

âœ… 3. Topic Exchange â†’ Send by pattern
ğŸ“Œ Example: A logging system that categorizes messages by error.* or info.*.
Messages are sent to queues whose Routing Key matches the specified pattern.

ğŸ” What is Fanout Exchange?
âœ… Fanout Exchange sends messages to all queues connected to it.
âœ… Each queue connected to this Exchange receives a copy of the message.

ğŸ“Œ Simple example:

In a company, the Human Resources (HR) system keeps information about employee hires and resignations.
The Accounting department needs to receive salary and benefits information.
The Marketing department also needs to receive information about new employees.
Both departments should receive a copy of the message!
âœ… Fanout Exchange solves this problem and sends the message to all connected queues.
ğŸ“Œ Fanout Exchange does not require a Routing Key, so leave it blank.

ğŸ” What is Direct Exchange?
âœ… Direct Exchange allows you to selectively send messages to specific queues only.
âœ… In this model, messages have a Routing Key and Exchange sends the message only to the queue that exactly matches this Routing Key.
ğŸ“Œ Simple example:
In an image upload system, we have three types of images: PNG, JPEG and SVG.
PNG and JPEG only need to generate Thumbnail.
SVG needs to be converted to PNG first and then Thumbnail is generated.
Here, we can create two different queues to process images:
q.picture.image for PNG and JPEG images
q.picture.vector for SVG images
âœ… With Direct Exchange, messages are sent to the appropriate queue based on the Routing Key.

We create a Direct Exchange called x.picture.
We create two queues to receive messages:
q.picture.image â†’ for PNG and JPEG
q.picture.vector â†’ for SVG
We create a producer that sends messages to x.picture.
We create two consumers that receive PNG and JPEG messages from q.picture.image and SVG messages from q.picture.vector.

q.picture.image â†’ connected to x.picture with Routing Key jpeg
q.picture.image â†’ connected to x.picture with Routing Key png
q.picture.vector â†’ connected to x.picture with Routing Key svg
ğŸ“Œ Now if a message is sent with Routing Key jpeg or png, it goes to q.picture.image.
ğŸ“Œ If a message is sent with Routing Key svg, it goes to q.picture.vector.
ğŸ“Œ If a message is sent with another Routing Key, it is not placed in any queue and is deleted!

We want to route messages based on multiple criteria. For this, we use Topic Exchange.
ğŸ¯ Scenario: Processing images with multiple criteria
We have a system that processes images. Things to do:
âœ… Create thumbnails and publish images (as before).
âœ… Convert SVG (vector) files to images.
âœ… Apply filters to images sent from mobile.
âœ… Create reports for large vectors (more than 4000 units of volume).

Here we need to route messages to different queues based on 3 properties:

Image source: from mobile or web.

Image size: small or large.

File type: jpeg, png or svg.
ğŸ›  Using Topic Exchange
In Topic Exchange, the routing key consists of 3 parts, which are . Separated
To send messages to the appropriate queues, we use special patterns (wildcards) in routing:
* matches exactly one word.
# matches zero or more words.

ğŸ“Œ Example:
The message mobile.large.png goes to 3 queues:
queue.picture.image (because it has a png type).
queue.picture.filter (because it was sent from mobile).
But it doesn't go to queue.picture.log because it's not a svg type.
The message web.small.svg only goes to queue.picture.vector.
The message mobile.large.svg goes to 3 queues:
queue.picture.vector (because it's a svg).
queue.picture.filter (because it was sent from mobile).
queue.picture.log (because it's a large and a svg).


