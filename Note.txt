What is a messaging system?
A messaging system is a mechanism for communication between applications (Application to Application or A2A). It manages messages between different applications and systems in an organization.

An example of a messaging system in use
Suppose a company has three systems:
Human Resources System (HR System): Manages information about new employees and those who have resigned.
Marketing System: Needs to receive employee information to manage its users.
Active Directory: Used to store usernames and passwords.
Without using a messaging system
A new employee is registered in the HR system resources.
The Marketing system must retrieve information from the HR database every hour and process it itself.
The Active Directory system only receives and processes new data once a day (at 1 am).
This method is that the transfer of information is delayed. Also, each system must be given different file methods (e.g. database, API, text) which adds complexity.

Using RabbitMQ
The HR system sends every change to RabbitMQ.
RabbitMQ receives the message and puts it in a queue.
The Market and Active Directory system receive and process both messages.
In this method, data transfer is done in real-time and there is no need to implement different schedules in different systems.

Major problems with old and important messaging system methods
If the number of applications increases, each application communicates with a large number of other applications. If you have P source applications and Q target applications, you need to set up P Ã— Q communication points which becomes very complicated.
Different communication methods (database, API, file) have different formats which are difficult to manage.
Direct communication may cause applications to crash.

Using RabbitMQ, systems are decoupled, meaning that:
The source system only sends to RabbitMQ.
The target system receives what it needs from RabbitMQ.
All systems communicate in a standard format (e.g. JSON).
RabbitMQ can process large amounts of data quickly.

Run the following command:
docker run -d --name rabbitmq \
  --restart unless-stopped \
  -p 5672:5672 -p 15672:15672 \
  -e RABBITMQ_DEFAULT_USER=admin \
  -e RABBITMQ_DEFAULT_PASS=admin123 \
  -v rabbitmq_data:/var/lib/rabbitmq \
  rabbitmq:management

unless-stopped: Restarts the container unless it has been manually stopped.
always: Even if manually stopped, it will be restarted after a system restart, which is sometimes unnecessary.


How does RabbitMQ work? A simple example
Let's assume we have a specific post office:
Person A logs into the post office and sends a message.
The post office places this message in a specific queue.
Person X has informed this post office that he is interested in messages from a specific queue.
Now, whenever a new message arrives in this queue, the post office sends it to person X to process.

What is Exchange and what does it do?
Exchange acts like a post office employee who sends messages to the appropriate queues.
When it receives a message, it must decide:
Should it send the message to a specific queue?
Should it send the message to several different queues?
Should it delete the message altogether?

ğŸ”¹ If the message needs to be sent to multiple queues, Exchange places a copy of the message in each queue.
Two important concepts: Message Durability and Queue Durability

ğŸ”¹ By default, RabbitMQ stores messages transiently.
That is, if the RabbitMQ server is shut down or crashes, the messages are lost.
Even the queue itself may be deleted unless we define it as Durable.

âœ… How to make messages and queues durable

When we create a queue, we must define it as Durable so that it is not lost after the server is shut down.
This causes the queue structure to be saved on disk and recreated after RabbitMQ is restarted.

Creating a Persistent Message
We must mark each message as Persistent when sending it so that RabbitMQ stores it on disk.
We do this by setting Delivery Mode = Persistent.
âœ… If both the queue and the message are durable, RabbitMQ will try to preserve the messages even if the server is down or crashes.

Simple summary:
RabbitMQ is like a post office that manages messages.
The Producer sends the message, the Exchange sends the message to the appropriate Queue, and the Consumer receives it.
To prevent message loss, we need to make the queue and messages durable and persistent.

Producer: Person A who sends the message - the application that sends the message to RabbitMQ.
Message: The message sent - the information being sent (e.g. a JSON string).
Queue: The queue where the message is placed - a place that holds messages until they are processed.
Consumer: Person X who receives the message - the application that receives and processes messages from the queue.
Subscribe: Person X registers with the post office - the process of expressing interest in receiving messages from a queue.
Consume: Message received by person X - receiving and processing the message from the queue.
Exchange (Message Router): The post office worker that sends messages to queues - the part that receives messages from the Producer and sends them to the appropriate queue.
Routing Key: A tag on the message that specifies which queue to send it to - an address that helps RabbitMQ send the message to the correct queue.
Binding: The connection between Exchange and Queue - the process that determines which Queue to send messages from Exchange to.

What is Classic Queue?
âœ… The default type of queues in RabbitMQ
âœ… Simple and widely used for most projects
âœ… Uses a master node to store messages
âœ… Fast performance, but less immune to message loss

ğŸ”¹ What is the problem with Classic Queue?
âŒ If the master node crashes, messages are lost!
âŒ Not suitable for projects with sensitive data.

ğŸ›  What projects is Classic Queue suitable for?
âœ… Simple systems with a RabbitMQ Server
âœ… Where losing some messages is not a problem
For example: non-sensitive messaging systems, push notifications, and ad-hoc processing

What is Quorum Queue?
âœ… Suitable for projects where messages should not be lost
âœ… Uses multiple nodes to store and backup messages
âœ… If a server crashes, data is not lost
âœ… Uses a consensus algorithm to synchronize data between nodes

ğŸ”¹ How does Quorum Queue protect messages?
ğŸ”¸ Each message is copied to multiple servers (Nodes)
ğŸ”¸ At least half of the nodes + 1 node must store the message
For example, if we have 5 RabbitMQ servers, the message is stored on 3 servers.

ğŸ›  What projects is Quorum Queue suitable for?
âœ… Projects where messages should not be lost
âœ… Banking and financial systems ğŸ’°
âœ… Healthcare and medical services ğŸ¥
âœ… Projects running in a Cluster environment

Which one should we choose in real projects (Production)?
âœ… If data safety and message loss are important â†’ Quorum Queue
âœ… If speed is more important than data safety and message loss is not a problem â†’ Classic Queue
âœ… In this course, both types can be used, but for the real environment (Production), it is better to use Quorum Queue.

Why use JSON? ğŸ¤”
RabbitMQ accepts any string as a message, which is very flexible. But this can cause problems.
ğŸ”¹ Problem: Different message formats
Suppose we have two producers that send messages in different formats:
Producer X separates its data with ||:
Producer Y separates its data with ;:
Now if a consumer (Consumer C) wants to receive these messages, it must know both formats and have different ways to process each format. This adds a lot of complexity to the code.
ğŸ”¹ Solution: Use JSON
With JSON, all the data is in a standard format. This means that different producers do not need to use different ways to separate the data.

ğŸ”¹ What is Exchange in RabbitMQ?
âœ… Exchange is a part of RabbitMQ that receives messages and sends them to the appropriate queues.
âœ… Exchange decides which queue the message should go to.
âœ… Exchange decides which Queue to send the message to based on the "Routing Key".
âœ… The connection between an Exchange and a Queue is called "Binding".

ğŸ”¹ There are different types of Exchanges, each of which sends messages to Queues in a specific way:
Fanout Exchange: Sends the message to all queues connected to the Exchange.
Direct Exchange: Sends the message to a specific queue whose Routing Key exactly matches.
Topic Exchange: Sends messages to different queues based on the Routing Key pattern.

ğŸ”¹ Simple Examples of Exchange Types
âœ… 1. Fanout Exchange â†’ Send message to all queues
ğŸ“Œ Example: Send a notification to all users
The message is sent to all queues connected to the Exchange, no matter what the Routing Key is.

âœ… 2. Direct Exchange â†’ Send to a specific queue
ğŸ“Œ Example: A payment system that sends "successful payment" messages only to the relevant queue.
The message is sent only to the queue whose Routing Key is exactly equal to the specified value.

âœ… 3. Topic Exchange â†’ Send by pattern
ğŸ“Œ Example: A logging system that categorizes messages by error.* or info.*.
Messages are sent to queues whose Routing Key matches the specified pattern.

ğŸ” What is Fanout Exchange?
âœ… Fanout Exchange sends messages to all queues connected to it.
âœ… Each queue connected to this Exchange receives a copy of the message.

ğŸ“Œ Simple example:

In a company, the Human Resources (HR) system keeps information about employee hires and resignations.
The Accounting department needs to receive salary and benefits information.
The Marketing department also needs to receive information about new employees.
Both departments should receive a copy of the message!
âœ… Fanout Exchange solves this problem and sends the message to all connected queues.
ğŸ“Œ Fanout Exchange does not require a Routing Key, so leave it blank.

ğŸ” What is Direct Exchange?
âœ… Direct Exchange allows you to selectively send messages to specific queues only.
âœ… In this model, messages have a Routing Key and Exchange sends the message only to the queue that exactly matches this Routing Key.
ğŸ“Œ Simple example:
In an image upload system, we have three types of images: PNG, JPEG and SVG.
PNG and JPEG only need to generate Thumbnail.
SVG needs to be converted to PNG first and then Thumbnail is generated.
Here, we can create two different queues to process images:
q.picture.image for PNG and JPEG images
q.picture.vector for SVG images
âœ… With Direct Exchange, messages are sent to the appropriate queue based on the Routing Key.

We create a Direct Exchange called x.picture.
We create two queues to receive messages:
q.picture.image â†’ for PNG and JPEG
q.picture.vector â†’ for SVG
We create a producer that sends messages to x.picture.
We create two consumers that receive PNG and JPEG messages from q.picture.image and SVG messages from q.picture.vector.

q.picture.image â†’ connected to x.picture with Routing Key jpeg
q.picture.image â†’ connected to x.picture with Routing Key png
q.picture.vector â†’ connected to x.picture with Routing Key svg
ğŸ“Œ Now if a message is sent with Routing Key jpeg or png, it goes to q.picture.image.
ğŸ“Œ If a message is sent with Routing Key svg, it goes to q.picture.vector.
ğŸ“Œ If a message is sent with another Routing Key, it is not placed in any queue and is deleted!

We want to route messages based on multiple criteria. For this, we use Topic Exchange.
ğŸ¯ Scenario: Processing images with multiple criteria
We have a system that processes images. Things to do:
âœ… Create thumbnails and publish images (as before).
âœ… Convert SVG (vector) files to images.
âœ… Apply filters to images sent from mobile.
âœ… Create reports for large vectors (more than 4000 units of volume).

Here we need to route messages to different queues based on 3 properties:

Image source: from mobile or web.

Image size: small or large.

File type: jpeg, png or svg.
ğŸ›  Using Topic Exchange
In Topic Exchange, the routing key consists of 3 parts, which are . Separated
To send messages to the appropriate queues, we use special patterns (wildcards) in routing:
* matches exactly one word.
# matches zero or more words.

ğŸ“Œ Example:
The message mobile.large.png goes to 3 queues:
queue.picture.image (because it has a png type).
queue.picture.filter (because it was sent from mobile).
But it doesn't go to queue.picture.log because it's not a svg type.
The message web.small.svg only goes to queue.picture.vector.
The message mobile.large.svg goes to 3 queues:
queue.picture.vector (because it's a svg).
queue.picture.filter (because it was sent from mobile).
queue.picture.log (because it's a large and a svg).

âŒ Problem: Messages that always have errors
Example: In the previous scenario, we were processing images. Now suppose an image is too large and causes an error in the Consumer.

ğŸ”¹ Spring Boot default behavior:
If the Consumer gets an error while processing the message, RabbitMQ will put the message back in the Queue to be processed later.

ğŸ”¹ But what is the problem?
If the message always causes an error (e.g. the image is too large and it throws an error every time it is processed), RabbitMQ will send the message over and over again, creating an infinite loop. ğŸ˜±

ğŸ”„ Solution: Dead Letter Exchange (DLX)
ğŸ”¹ If a message is processed multiple times and still has an error, we send it to a special queue called Dead Letter Queue (DLQ).
ğŸ”¹ This queue stores problematic messages to be reviewed later.
ğŸ”¹ We can write a separate Consumer to process these messages, for example:

Send the message to the system administrator.

Store the message in a database for further review.

ğŸ¯ How does DLX work?
âœ… 1. The message is entered into the main Queue (e.g. q.picture.processing).
âœ… 2. If the processing was successful, the message is deleted.
âœ… 3. If the message has an error and is retried several times, RabbitMQ sends it to a Dead Letter Exchange (DLX).
âœ… 4. The DLX stores the message in the Dead Letter Queue (DLQ).
âœ… 5. Another Consumer can process these problematic messages.

ğŸ“Œ How to store messages in RabbitMQ
1ï¸âƒ£ Memory-Only Queues

By default, if your queue is not durable, messages are stored only in memory.
These types of queues are faster, but if RabbitMQ crashes or restarts, messages are lost.
2ï¸âƒ£ Persistent Messages

If you make the queue durable and send the message Persistent, the message is stored on disk.
In this case, if RabbitMQ is restarted, the messages are not lost.

ğŸ“Œ Are all messages always in memory?
ğŸ”¹ RabbitMQ stores messages in memory (RAM) first to speed up processing.
ğŸ”¹ If memory is full, RabbitMQ moves old messages to disk to free up memory space.
ğŸ”¹ This process is called Lazy Queue, which reduces RAM usage.

ğŸ“Œ Differences between RabbitMQ and Kafka in message storage
RabbitMQ Kafka feature
Queue type
RabbitMQ : Queue-based (messages are sent to one or more consumers and deleted)
Kafka : Log-based (messages are stored in the log and consumers only advance one offset)

Retention time
RabbitMQ : By default, the message is destroyed after the consumer receives it unless Dead Letter Queue (DLQ) is configured
Kafka : Messages are stored in the log for a specified period of time (e.g. 7 days), even after the consumer receives it

Disk storage
RabbitMQ : If the queue is Durable and a Persistent message is sent, the message is stored on disk. But when it is consumed, it is deleted.
Kafka : All messages are stored on disk by default and are not deleted until the TTL or disk space limit is reached

Processing model
RabbitMQ : Push-based (messages are sent to the consumer)
Kafka : Pull-based (consumers themselves receive messages from Kafka)

Main use
RabbitMQ : Suitable for distributed systems that require real-time messaging
Kafka : Suitable for processing large volumes of data and streaming

â³ What is TTL (Time To Live) in RabbitMQ?
TTL in RabbitMQ means that a message will only remain in the queue for a certain period of time and if it is not consumed within this period, it will be deleted or sent to the Dead Letter Exchange (DLX).

ğŸ“Œ How does TTL work?
Each message can have a TTL.
ğŸ”¹ This means that, for example, a message can remain in the queue for a maximum of 30 seconds.

Each queue can also have a TTL.
ğŸ”¹ This means that all messages in a queue should not remain in it for more than 60 seconds.

If the TTL expires:
âœ… If the queue has a Dead Letter Exchange (DLX), the message is sent there.
âŒ If DLX is not set, the message is deleted.

ğŸ“Œ Why is TTL important?
ğŸ”¹ Managing old messages: If messages become old and are not processed, we delete them or move them to DLX.
ğŸ”¹ Create a Retry mechanism: Failed messages can be retried with a specified delay.
ğŸ”¹ Reduce system pressure: Removing old messages from the queue makes RabbitMQ work faster.

ğŸ“Œ TTL + Dead Letter Exchange (DLX) = Retry mechanism
If a consumer does not receive a message or rejects it due to an error, a retry mechanism can be built with the help of DLX and TTL:
The message is placed in the Main Queue.
If it is not consumed, it is sent to the Dead Letter Queue (DLQ) after the TTL.
The consumer reads the message from the DLQ and retransmits it.
This cycle can be repeated for several times.

ğŸ“Œ Scenario: Handling Invalid Messages with DLX
âœ… Problem:
ğŸ”¹ We have an image processing system that receives and processes images.
ğŸ”¹ If the image is more than 9000 bytes, the Consumer throws an error and RabbitMQ re-queues it.
ğŸ”¹ This process continues indefinitely, causing the message to get stuck in an infinite loop.

âœ… Solution:
ğŸ”¹ To avoid this problem, we use Dead Letter Exchange (DLX).
ğŸ”¹ When a consumer fails to process a message, RabbitMQ sends it to the Dead Letter Queue (DLQ).
ğŸ”¹ Another consumer receives messages from the DLQ and handles the invalid messages.

What is AmqpRejectAndDontRequeueException in RabbitMQ?
In Spring AMQP, when a consumer encounters an error while processing a message, it will requeue the message by default to requeue it.
But in some cases, we don't want the message to be requested, because it will always cause an error (for example, the message format is wrong or the image size is too large).
ğŸ”¹ In these situations, we can throw an exception (AmqpRejectAndDontRequeueException).
ğŸ”¹ This exception causes the message to not be requested and go to the Dead Letter Exchange (DLX) (if DLX is configured).

What is AMQP?
ğŸ”¹ AMQP (Advanced Message Queuing Protocol) is a standard and open-source protocol for sending and receiving messages between different systems.
ğŸ”¹ This protocol helps manage message queues and ensures that messages are processed without loss and in the correct order.

ğŸ“Œ What is the AMQP architecture?
AMQP consists of three main parts:
1ï¸âƒ£ Producer â†’ Sends messages to an Exchange.
2ï¸âƒ£ Exchange â†’ Processes messages and sends them to different Queues based on rules.
3ï¸âƒ£ Consumer â†’ Receives and processes messages from the Queue.
ğŸ“Œ Note:
AMQP and RabbitMQ are different!
AMQP is a standard protocol.
RabbitMQ is a Message Broker that supports AMQP.





